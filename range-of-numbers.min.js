'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 *
 * A function to produce an Array of integer values from 's' to 'e' inclusive.
 * With optional step amount.
 *
 * @sig (n,n,n) -> [n]
 * @param {Number} : [s] start index
 * @param {Number} : [e] end index
 * @param {Number} : [st] step amount
 * @return {Array} A new array with Integer values
 * @example
 *   range(-2,7)    //=> [-2, -1, 0, 1, 2, 3, 4, 5, 6, 7]
 *   range(-5,5, 2) //=> [-5, -3, -1, 1, 3, 5]
 *   range(10,5)    //=> [10, 9, 8, 7, 6, 5]
 *   range(10,0,4)  //=> [10, 6, 2]
 *   range(0,10000000).length //=> 10000001
 *
 */

var range = ((s, e, st = 1) => {
  let oneArg = false;
  if (typeof s !== 'number' || typeof st !== 'number') {
    return Error("All inputs must be of type 'number'");
  } else if (typeof e !== 'number') {
    oneArg = true;
  }

  if (st < 1) return Error('Step must be a positive integer');

  const start = parseInt(s);
  const end = parseInt(e);
  const step = parseInt(st);

  const fillArr = function (s, e) {
    let result = Array(Math.floor((e - s) / step) + 1);
    for (let i = s; i <= e; i += step) {
      const idx = Math.floor((i - s) / step);
      result[idx] = i;
    }
    return result;
  };

  const fillArrRev = function (s, e) {
    let result = Array(Math.floor((s - e) / step) + 1);
    for (let i = s, num = 0; i >= e; i -= step) {
      result[num++] = i;
    }
    return result;
  };

  if (start < end) {
    return fillArr(start, end);
  } else if (start > end) {
    return fillArrRev(start, end);
  } else if (oneArg) {
    return fillArr(0, start);
  } else {
    return [start];
  }
});

/**
 *
 * A function to produce an Array of integer values from 's' to 'e' inclusive.
 * With optional step amount. Implemented using a Promise
 *
 * @sig (n,n,n) -> [n]
 * @param {Number} : [s] start index
 * @param {Number} : [e] end index
 * @param {Number} : [st] step amount
 * @return A Promise of an {Array} with Integer values or {Error}
 * @example
 *   const lt100 = arr => arr.filter(el => el < 100)
 *   const gtNeg100 = arr => arr.filter(el => el > -100)
 *   const multOf7 = arr => arr.filter(el => el % 7 === 0)
 *   const evens = arr => arr.filter(el => el % 2 === 0)
 *   range(-80, 100, 3)
 *     .then(lt100)
 *     .then(gtNeg100)
 *     .then(evens)
 *     .then(multOf7)
 *     .then(console.log)  //=> [-56, -14, 28, 70]
 *     .catch(console.log)
 *
 */

var rangePromise = ((start, end, step = 1) => {
  let _start = parseInt(start);
  let _end = parseInt(end);
  let _step = parseInt(step);

  const fillArr = function (s, e, st) {
    let result = Array(Math.floor((e - s) / st) + 1);
    for (let i = s; i <= e; i += st) {
      const idx = Math.floor((i - s) / st);
      result[idx] = i;
    }
    return result;
  };

  const fillArrRev = function (s, e, st) {
    let result = Array(Math.floor((s - e) / st) + 1);
    for (let i = s, num = 0; i >= e; i -= st) {
      result[num++] = i;
    }
    return result;
  };

  return new Promise((resolve, reject) => {
    try {
      if (_step < 1) {
        throw Error('Step must be a positive integer');
      }

      if (isNaN(_start)) {
        throw Error("All inputs must be of type 'number'");
      } else if (isNaN(_end)) {
        _end = _start;
        _start = 0;
      }
      //console.log('start/end', _start, _end)
      if (_start < _end) {
        resolve(fillArr(_start, _end, _step));
      } else if (_start > _end) {
        resolve(fillArrRev(_start, _end, _step));
      } else if (_start === _end) {
        resolve([_start]);
      } else {
        throw Error('something bad.');
      }
    } catch (e) {
      reject(e);
    }
  });
});

exports.rangePromise = rangePromise;
exports.range = range;
